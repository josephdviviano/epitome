#!/usr/bin/env python
"""
                               _ _                        
                              (_) |                       
                     ___ _ __  _| |_ ___  _ __ ___   ___  
                    / _ \ '_ \| | __/ _ \| '_ ` _ \ / _ \ 
                   |  __/ |_) | | || (_) | | | | | |  __/ 
                    \___| .__/|_|\__\___/|_| |_| |_|\___| 
                        | |                               
                        |_|                               
Usage:

    epitome help                -- prints help for selected module.
    epitome verify <experiment> -- checks input files for experiment.
    epitome check               -- checks installation paths & environment.
    epitome run                 -- produce pre-processing and QC scripts.
    epitome clean               -- produce clean-up scripts.

"""

import os, sys, stat
from copy import copy
import epitome as epi

def get_modules(moduletype='pre', used=[]):
    """
    Prints the available modules. Optionally prompts the user to select one.
    If provided with a list of 'used' modules, these are stripped from the
    output.
    """
    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # get a sorted list of the modules
    dir_modules = os.path.join(dir_pipe, 'epitome/modules', str(moduletype))

    # try to import a list of the module types
    try:
        module_list = [f for f in os.listdir(dir_modules)
                               if os.path.isfile(os.path.join(dir_modules, f))]
    except:
        # if the module type does not exist, throw an error
        module_types = os.listdir(os.path.join(dir_pipe, 'epitome/modules'))
        print('Invalid module type. Available:\n')
        for m in module_types:
            print('    ' + str(m))
        return None

    # if we get a used list, remove them from the module list
    if used != None:
        for u in used:
            try:
                module_list.remove(u)
            except:
                pass

    try:
        selection = epi.utilities.selector_list(module_list)
        used.append(selection)
        return selection, used
    except ValueError as ve:
        print('Invalid selection')
        return None, used

def get_mode(expt):
    """
    Prints the available image modalities. Optionally prompts the user to 
    select one.
    """

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # get a sorted list of the experiments
    dir_expt = os.path.join(dir_data, expt)
    subj_list = [d for d in os.listdir(dir_expt)
                         if os.path.isdir(os.path.join(dir_expt, d))]
    dir_subj = os.path.join(dir_expt, subj_list[0])
    mode_list = [d for d in os.listdir(dir_subj)
                         if os.path.isdir(os.path.join(dir_subj, d))]

    try:
        selection = epi.utilities.selector_list(mode_list)
        return selection
    except ValueError as ve:
        print('Invalid selection')
        sys.exit()

def get_experiments(check=None):
    """
    Prints the available experiments. Optionally prompts the user to select
    one.
    """

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # check permissions
    if epi.utilities.has_permissions(dir_data) == False:
        sys.exit()

    # get a sorted list of the experiments
    expt_list = [d for d in os.listdir(dir_data)
                         if os.path.isdir(os.path.join(dir_data, d))]

    try:
        selection = epi.utilities.selector_list(expt_list)

        # this is for the commandline usage
        if check == 'check':
            check_directories(selection)
        # this is an internal usage
        else:
            return selection

    except ValueError as ve:
        print('Invalid selection')
        sys.exit()

def writer(p_list, line, filename, f, output, bkup, mode):

    if mode == 'sub':
        filename = '${DIR_DATA}/${DIR_EXPT}/${SUB}/' + filename
    elif mode == 'exp':
        filename = '${DIR_DATA}/${DIR_EXPT}/' + filename


    # output will == None if we made a mistake
    if output != None:
        out_line = line + ' >> ' + filename + '\n'
        f.write(out_line)
        p_list.append(line)

    # if we did make a mistake, restore the old output
    else:
        output = copy(bkup)

    return p_list, output

def get_date_user():
    """
    Returns a eyeball-friendly timestamp, the current user's name, 
    and a filename-friendly timestamp.
    """
    import time
    import getpass

    datetime = time.strftime("%Y/%m/%d -- %H:%M:%S")
    user = getpass.getuser()
    f_id = time.strftime("%y%m%d_%H%M%S")

    return datetime, user, f_id

def print_help(module):

    import textwrap
    
    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # print the contents of the JSON line by line, wrapping long sections
    print('')
    if module != None:
        helpfile = open(os.path.join(dir_pipe, 'doc/' + module + '.md'), 'rb')
        helpfile = helpfile.readlines()

        for line in helpfile:
            if len(line) < 80:
                print line.strip('\n')
            else:
                print("\n".join(textwrap.wrap(line)))

def help_query():

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # ask which module type we want to look at
    module_types = os.listdir(os.path.join(dir_pipe, 'epitome/modules'))

    try: 
        response = epi.utilities.selector_list(module_types)
    except ValueError as ve:
        print("""You didn't input a valid number! Default = 'pre'.""")
        response = 'pre'

    print('Which module do you need help with?')
    module, used = get_modules(moduletype=str(response))
    print_help(module)

def check_paths():
    """
    This ensures paths defined in config.py are actual directories, and checks
    that the AFNI physio regression programs are configured properly..
    """

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

   
    if dir_data == None:
        print('EPITOME_DATA variable is not set!') 
    elif os.path.isdir(dir_data) == None:
        print('Data directory does not exist:' + str(dir_data))

    dir_pipe = epi.config.find_epitome()
    if dir_pipe == None:
        print('epitome is not on your path (how are you running me??)')

    dir_afni = epi.config.find_afni()
    if dir_afni == None:
        print('AFNI is not on your path.')

    dir_matlab = epi.config.find_matlab()
    if dir_matlab == None:
        txt = ('\nMATLAB / MATLAB compiler runtime v715 is not on your path!\n'
               'If you need MATLAB, Download the MATLAB v715 2011b compiler,\n'
               '        http://afni.nimh.nih.gov/sscc/dglen/McRetroTS       \n')
        print(txt)

    else:
        txt = ('\nepitome/config.py appears to be properly configured\n'
               '    data directory: {dir_data}\n'
               '    pipeline directory: {dir_pipe}\n'
               '    AFNI directory: {dir_afni}\n'
               '    MATLAB found: {dir_matlab} \n'.format(
                    dir_data=dir_data,
                    dir_pipe=dir_pipe,
                    dir_afni=dir_afni,
                    dir_matlab=dir_matlab))
        print(txt)

def check_run(expt, subj, mode, sess, run):
    """
    Returns True if RUN folder contains a NIFTI file, False otherwise.

    Usage:
        truth = check_run(experiment, subject, image modality, session, run)
    """

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # retrieve the number of files within each run folder
    dir_file = os.path.join(dir_data, expt, subj, mode, sess, run)
    file_list = [d for d in os.listdir(dir_file)
                         if os.path.isfile(os.path.join(dir_file, d))]

    n_files = filter(lambda x: x[-7:] == '.nii.gz' or 
                               x[-4:] == '.nii', file_list)
    n_files = len(n_files)

    return n_files

def check_mode(expt, subj, mode):
    """
    This returns each image modality's total number of runs and checks for run
    folders with missing data.
    """

    # start a run counter
    n_runs = 0

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()
    
    # retrieve the sessions for a given image modality
    dir_mode = os.path.join(dir_data, expt, subj, mode)
    sess_list = [d for d in os.listdir(dir_mode)
                         if os.path.isdir(os.path.join(dir_mode, d))]
    
    # retrieve runs for a given session
    for sess in sess_list:
        dir_sess = os.path.join(dir_mode, sess)
        run_list = [d for d in os.listdir(dir_sess)
                            if os.path.isdir(os.path.join(dir_sess, d))
                            and d[0:3] == 'RUN']

        # check for runs missing/too many NIFTI files, print warnings
        for run in run_list:
            n_files = check_run(expt, subj, mode, sess, run) 
            n_runs = n_runs + n_files
            
            if n_files == 0:
                print("""subject {subj}, {mode}, sess {sess}, run {run} \
                         contains no NIFTI file.""".format(subj=str(subj), 
                                                           mode=str(mode),
                                                           sess=str(sess), 
                                                           run=str(run)))
            if n_files > 1:
                print("""subject {subj}, {mode}, sess {sess}, run {run} \
                         contains {n} NIFTI files.""".format(subj=str(subj), 
                                                             mode=str(mode),
                                                             sess=str(sess), 
                                                             run=str(run),
                                                             n=str(n_files)))
    return n_runs

def check_directories(expt):
    """
    This checks the image modalities for each subject in an experiment. It also
    reports the number of subjects with each kind of image modality.
    """

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    # check permissions
    if epi.utilities.has_permissions(os.path.join(dir_data, expt)) == False:
        sys.exit()
    
    # attempt to access the subjects for a given experiment
    try:
        subjects = epi.utilities.get_subj(os.path.join(dir_data, expt))
    except:
        print('Your experiment path is incorrect ' + str(expt))

    # this dict will hold our count
    mode_dict = {}

    # loop through subjects, returning image modality counts, and record
    for subj in subjects:
        
        # retrieve the image modalities for a given subject 
        dir_subj = os.path.join(dir_data, expt, subj)
        mode_list = [d for d in os.listdir(dir_subj) 
                             if os.path.isdir(os.path.join(dir_subj, d))]
        
        for mode in mode_list:    
            # check inside each modality, get the number of sessions
            n_runs = check_mode(expt, subj, mode)
            
            # add them to the count
            try:
                mode_dict[str(mode)] = mode_dict[str(mode)] + n_runs
            except:
                mode_dict[str(mode)] = n_runs

    # print out the file counts per image modality
    print('')
    for mode_key in mode_dict:
        print('    ' + str(mode_dict[mode_key]) + ' NIFTIs in ' + str(mode_key))
    print('')

def check_os():
    """
    Ensures the user isn't Bill Gates.
    """

    import platform

    operating_system = platform.system()
    if operating_system == 'Windows':
        print("""
              Windows detected. epitome requires Unix-like operating systems!
              """)
        sys.exit()

# The Cleanup Pipeline
###############################################################################
def run_cleanup():
    """
    Prints out scripts used to manage / remove epitome outputs.
    """
    check_os()

    print('epitome cleanup: THIS DELETES DATA.')

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths() 

    # get the experiment
    flag = 0
    while flag == 0:
        expt = get_experiments()
        if expt == None:
            print('')
        else:
            flag = 1
    
    print('Experiment: ' + str(expt) + '. Select image modality.\n')
 
    # get the mode
    flag = 0
    while flag == 0:
        mode = get_mode(expt)
        if mode == None:
            print('')
        else:
            flag = 1

    # get the date and time, current user, f_id
    datetime, user, f_id = get_date_user()

    # generate the unique filenames for this run
    clean = 'clean_' + f_id + '.sh'

    # open up the master script, write common variables
    f = open(os.path.join(dir_data, expt, clean), 'wb')

    txt = ('#!/bin/bash\n\n'
           '# Master script for {expt}: {mode}.\n'
           '# Generated: {datetime} by {user}.\n\n'
           '## Setup\n'
           'export DIR_PIPE={dir_pipe}\n'
           'export DIR_DATA={dir_data}\n'
           'export DIR_AFNI={dir_afni}\n'
           'export DIR_EXPT={expt}\n'
           'export DATA_TYPE={mode}\n'
           'export CORES={cores}\n'
           'export AFNI_DECONFLICT=OVERWRITE\n'.format(
                expt=expt, 
                mode=mode,
                user=user,
                cores=cores,  
                datetime=datetime, 
                dir_pipe=dir_pipe, 
                dir_data=dir_data, 
                dir_afni=dir_afni))

    # get the subjects
    print('\nWould you like to cleanup all subjects, or just some?')
    flag = 0
    while flag == 0:
        output = ''
        choice = ['all', 'some']
        try:
            decision = epi.utilities.selector_list(choice)
            flag = 1
        except ValueError as ve:
            print ('Invalid selection, please try again.')

    # optionally allow me to only clean up some subjects
    if decision == 'some':
        flag = 0
        subjects = []
        while flag == 0:
            print('Please select a subject.')
            output = ''
            subj_list = epi.utilities.get_subj(os.path.join(dir_data, expt))

            try:
                subj = epi.utilities.selector_list(subj_list)
                subjects.append(subj)
            except ValueError as ve:
                print('Invalid subject, please try again.')

            print('\nThe following subjects are slated for cleanup:\n')
            for subj in subjects:
                print(subj)
            print('')
            response = raw_input("""Type 'stop' to stop, else continue: """)

            if response == 'stop':
                flag = 1

    # otherwise just get the whole list
    elif decision == 'all':
        subjects = epi.utilities.get_subj(os.path.join(dir_data, expt))
        print('\nThe following subjects are slated for cleanup:\n')
        for subj in subjects:
            print(subj)
        print('')

    # print these subjects to the script
    f.write('export SUBJECTS="')
    for subj in subjects:
        f.write(str(subj) + ' ')
    f.write('"\n')

    # close down the file (cleanup commands added via cleanup.py)
    f.write('## Cleanup Commands \n\n')
    f.close()

    # now loop through the cleanup modules until the user aborts
    flag = 0 # breaks us out of the loop
    while flag == 0:

        print('\nPlease select the next cleanup module:\n')
        module, used = get_modules(moduletype='cleanup')
        if module == None:
            print('')
        else:
            # executes the chosen module, write cleanup commands
            command = 'epi.commands.' + str(module) + '.run(expt, clean)'
            eval(command)
        
        # ask if we should continue
        response = raw_input("""Type 'stop' to stop, else continue: """)
        if response == 'stop':
            flag = 1

    # print some final remarks
    print('******************************************************************')
    print('The cleanup script can be manually executed via:\n' + 
           '. ' + str(os.path.join(dir_data, expt, clean)) + '\n' +
           'and the user must manually OK each clean-up step.')
    print('******************************************************************')

# The Actual Pipeline 
###############################################################################
def run_epitome():

    check_os()
    print('\nRunning epitome. Select experiment.')

    # retrieve settings from config.py
    dir_data, dir_pipe, dir_afni, cores = epi.config.return_paths()

    dir_afni = epi.config.find_afni()
    dir_pipe = epi.config.find_epitome()
    dir_matlab = epi.config.find_matlab()

    # make sure we have permissions to access the experiment directory.
    if epi.utilities.has_permissions(dir_data) == False:
        sys.exit()

    # get the experiment
    flag = 0
    while flag == 0:
        expt = get_experiments()
        if expt == None:
            print('')
        else:
            flag = 1

    # now check to make sure we have experiment-specific permissions.
    if epi.utilities.has_permissions(os.path.join(dir_data, expt)) == False:
        sys.exit()

    # input unique identifier
    print('\nInput unique identifier for this pipeline (alphanumeric):')

    # replace spaces with underscores, and remove every other special char
    ID = raw_input('ID: ')
    ID = ID.replace(' ', '_')
    ID = ID.strip(",./;'[]\|-=+<>?:{}!@#$%^&*()`~")
    ID = ID.strip('"')

    # get the date and time, current user, f_id
    datetime, user, f_id = get_date_user()
    master = 'master_{f_id}_{ID}.sh'.format(f_id=f_id, ID=ID)
    cmd = 'cmd_{f_id}_{ID}.sh'.format(f_id=f_id, ID=ID)
    proc = 'proclist_{f_id}_{ID}.sh'.format(f_id=f_id, ID=ID)

    # create a copy of the pipeline in the user's home directory
    print('\nReplicating the current pipeline in ~/epitome/' +str(ID) + '.')

    # make the epitome directory if required
    if os.path.isdir('/home/' + str(user) + '/epitome') == False:
        os.system('mkdir /home/' + str(user) + '/epitome')

    # make the unique ID folder for this module set
    localpath = '/home/{user}/epitome/{ID}'.format(user=user, ID=ID)
    if os.path.isdir(localpath) == True:
        print('UID already exists, skipping replication.')
        pass
    
    # replicate the pipeline into the home folder
    else:
        os.system('mkdir ' + localpath)
        os.system('cp -r {pipe}/bin {path}'.format(pipe=dir_pipe, 
                                                     path=localpath))
        os.system('cp -r {pipe}/doc {path}'.format(pipe=dir_pipe, 
                                                     path=localpath))
        os.system('cp -r {pipe}/epitome {path}'.format(pipe=dir_pipe, 
                                                         path=localpath))
        dir_pipe = copy(localpath)

    print('\nExperiment: ' + str(expt) + '. Select image modality.')

    # get the mode
    flag = 0
    while flag == 0:
        mode = get_mode(expt)
        if mode == None:
            print('')
        else:
            flag = 1

    print('\nImage Modality: ' + str(mode) + '. Adding Freesurfer stages.')

    # open up the master script, write common variables
    f = open(os.path.join(dir_data, expt, master), 'wb')

    txt = ('#!/bin/bash\n\n'
           '# Master script for {expt}: {mode}.\n'
           '# Generated: {datetime} by {user}.\n\n'
           '## Setup\n'
           'export DIR_PIPE={dir_pipe}\n'
           'export DIR_DATA={dir_data}\n'
           'export DIR_AFNI={dir_afni}\n'
           'export DIR_EXPT={expt}\n'
           'export DATA_TYPE={mode}\n'
           'export ID={ID}\n'
           'export CORES={cores}\n'
           'export AFNI_DECONFLICT=OVERWRITE\n'
           'export SUBJECTS=$(python ${{DIR_PIPE}}/epitome/utilities.py ' 
           '${{DIR_DATA}} ${{DIR_EXPT}})\n\n'
           '## Freesurfer\n'
           'epi-fsrecon {dir_data} {expt} {mode} {fullproc}\n'
           '. ${{DIR_PIPE}}/epitome/modules/freesurfer/fsexport '
           '${{DIR_DATA}} ${{DIR_EXPT}} '
           '>> ${{DIR_DATA}}/${{DIR_EXPT}}{proc}\n\n'
           '## Begin Pipeline\n'
           'for SUB in ${{SUBJECTS}}; do\n\n'
           'cat > ${{DIR_DATA}}/${{DIR_EXPT}}/${{SUB}}/{cmd} << EOF\n'
           'export DIR_PIPE=${{DIR_PIPE}}\n'
           'export DIR_DATA=${{DIR_DATA}}\n'
           'export DIR_AFNI=${{DIR_AFNI}}\n'
           'export DIR_EXPT=${{DIR_EXPT}}\n'
           'export DATA_TYPE=${{DATA_TYPE}}\n'
           'export ID=${{ID}}\n'
           'export SUB=${{SUB}}\n'
           'McRetroTS={dir_pipe}bin/run_McRetroTS.sh {dir_matlab}\n'
           'EOF\n\n'.format(
                ID=ID, 
                cmd=cmd,
                expt=expt, 
                mode=mode,
                proc=proc,
                user=user,
                cores=cores,  
                fullproc=os.path.join(dir_data, expt, proc),
                datetime=datetime, 
                dir_pipe=dir_pipe, 
                dir_data=dir_data, 
                dir_afni=dir_afni,
                dir_matlab=dir_matlab))               
    f.write(txt)

    # we always start the pipeline with init_EPI
    print('\nBeginning pipeline construction.')

    p_list = [] # keeps track of our command-list
    flag = 0 # breaks us out of the loop
    while flag == 0:    
        
        #
        #
        # -- THIS IS WHERE I WILL ADD THE PATHWAY OPTIONS:
        #       --> DTI, HCP, fMRI, etc...
        #       --> current 'PRE' pipeline becomes 'fMRI' 
        #
        #
        # add init_EPI, check for mistakes, break the loop if flawless
        line, output = epi.commands.init_epi.run()
        p_list, output = writer(p_list, line, cmd, f, output, None, 'sub')
        if output != None:
            used = ['init_epi'] # start the 'used module' list
            flag = 1 # breaks us out of the loop
 
    # add user-defined modules
    flag = 0 # breaks us out of the loop
    while flag == 0:

        print('\nPlease select the next pipeline module:\n')
        module, used = get_modules(moduletype='pre', used=used)

        if module == None:
            print('')
        else:
            # save the old output
            bkup = copy(output)

            # executes the chosen module, write pipeline commands
            command = 'epi.commands.' + str(module) + '.run(output)'
            line, output = eval(command)

            # if module call was unsuccessful, don't count as used.
            if output == None:
                used.pop()
            
            # write line in script if successful
            p_list, output = writer(p_list, line, cmd, f, output, bkup, 'sub')

        # print the current pipeline configuration, ask to continue
        print('\nCurrent pre-processing pipeline:')
        for pipe in p_list:
            print('    ' + str(pipe))
        print('')
        response = raw_input("""Type 'stop' to stop, else continue: """)
        # breaks us out of the pipeline constructor loop
        if response == 'stop':
            flag = 1

    # add each subject to the proclist, close the subject loop
    txt = ('\nchmod 750 ${{DIR_DATA}}/${{DIR_EXPT}}/${{SUB}}/{cmd}\n'
           '# append this subject to the process queue\n'
           'echo bash ${{DIR_DATA}}/${{DIR_EXPT}}/${{SUB}}/{cmd} '
           '>> ${{DIR_DATA}}/${{DIR_EXPT}}/{proc}\n'
           'done\n\n'
           '# calls to QC programs\n'.format(cmd=cmd, proc=proc))
    f.write(txt)

    # add user-defined qc runs    
    p_list = [] # keeps track of our command-list
    flag = 0 # breaks us out of the loop
    used = []
    while flag == 0:

        print('\nPlease select the next QC module:')
        module, used = get_modules(moduletype='qc', used=used)
        if module == None:
            print('')
        else:
            # save the old output
            bkup = copy(output)
             
            # executes the chosen module, write pipeline commands
            command = ('epi.commands.' + str(module) + 
                         '.run(dir_data, expt, mode)')
            line, output = eval(command)
            p_list, output = writer(p_list, line, proc, f, output, bkup, 'exp')

        # print the current pipeline configuration, ask to continue
        print('\nThe QC pipeline currently looks like this:')
        for pipe in p_list:
            print pipe
        print('')
        response = raw_input("""Type 'stop' to stop, else continue: """)
        # breaks us out of the pipeline constructor loop
        if response == 'stop':
            flag = 1

    print('\nSaving master script & generating subject-specific scripts.')
    # close the file, make executable by owner + group, and execute
    f.write('\n')
    f.close()
    os.chmod(os.path.join(dir_data, expt, master), 0750)
    os.system('bash ' + os.path.join(dir_data, expt, master))

    # print some final remarks
    print('******************************************************************')
    print('The pipeline can be manually executed via:\n' + 
           '. ' + str(os.path.join(dir_data, expt, proc)) + '\n' +
           'or submitted to the queue via:\n' +
           'epi-queue ' + str(os.path.join(dir_data, expt, proc))+'queuename.q')
    print('******************************************************************')

# this is the command-line usage bit
if __name__ == "__main__":
    
    # listing available modules and associated help
    if len(sys.argv) == 2 and sys.argv[1] == 'help':
        help_query()
    
    elif len(sys.argv) == 2 and sys.argv[1] == 'verify':
        print('Please specify an experiment.')
        get_experiments(check='check')

    elif len(sys.argv) == 3 and sys.argv[1] == 'verify':
        check_directories(sys.argv[2]) 

    elif len(sys.argv) > 3 and sys.argv[1] == 'verify':
        print 'epitome check only works with 1 experiment at a time!'

    # checking functions
    elif len(sys.argv) == 2 and sys.argv[1] == 'check':
        check_paths()

    elif len(sys.argv) == 2 and sys.argv[1] == 'clean':
        run_cleanup()

    # for running the command-line interface
    elif len(sys.argv) == 2 and sys.argv[1] == 'run':
        run_epitome()

    # return the usage if the user does a silly thing
    else:
        print(__doc__)
